# 21

[이전](./20.md)|[index 페이지로](./00index.md) |[다음](./22.md)
---|---|---
<hr>

## REDIS
### 목차

1. [개요](#개요)
1. [NoSQL](#nosql)
1. [Redis 상세](#redis-상세)
1. [CRUD에 따른 Redis 데이터 처리](#crud에-따른-redis-데이터-처리)

# Redis

### 개요

redis(REmote DIctionary Server)는 NoSQL의 하나로, key-value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 DBMS.



### NoSQL?

- 개요

  **비관계형 데이터베이스**(Not Only SQL)라는 뜻으로  기존의 관계형 DBMS가 갖고있는 특성 뿐만 아니라 다른 특성들을 부가적으로 지원한다는 것을 의미한다.



- 특징 

  기존의 관계형 데이터베이스보다 더 융통성있는 데이터 모델을 사용하며, 데이터의 저장 및 검색을 위한 특화된 메커니즘을 제공한다. 

  이를 통해 NoSQL 데이터베이스는 단순 검색 및 추가작업에 있어서 매우 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에 있어서 매우 뛰어난 성능을 나타낸다.

  

  - 관계형 모델을 사용하지 않으며 테이블 간 연결해서 조회할 수 있는 조인 기능이 없음

  - 데이터 조회를 위해 직접 프로그래밍하는 등의 비 SQL 인터페이스를 통한 데이터 접근

  - 대부분 여러 데이터베이스 서버를 묶어서(클러스터링) 하나의 데이터베이스를 구성

  - 관계형 데이터베이스에서는 지원하는 데이터 처리 완결성(Transaction, ACID 지원)이 보장되지 않음

  - 데이터의 스키마와 속성들을 다양하게 수용하고 동적으로 정의(Schemaless)

  - 데이터베이스의 중단없는 서비스와 자동 복구 기능 지원

  - 대다수의 제품이 Open Source로 제공

  - 대다수의 제품이 고 확장성, 고 가용성, 고 성능 특징을 가짐

  



### Redis 상세

1. 오픈 소스 소프트웨어이다.
2. 디스크가 아닌 **메모리 기반**의 데이터 저장소이다. 
   (In-Memory data structure store)
3. **NoSQL & Cache 솔루션**이며 메모리 기반으로 구성된다.
4. 명시적으로 삭제, Expire를 설정하지 않으면 데이터는 삭제되지 않는다.(= **영구적 보존**)
5. 여러대의 서버 구성 가능하다.
6. 데이터베이스로 사용될 수 있으며 Cache로도 사용될 수 있는 기술이다.
7. 성능은 서버에 따라 다르나 초당 2만 ~ 10만회 수행한다.



- 사용가능 데이터 타입
  - String
  - Lists
  - Sets
  - Sorted sets
  - Hashs



- 장점

  - 리스트, 배열과 같은 데이터를 처리하는데 유용하다.
    - value 값으로 String, List, Set, Sorted set, Hash 등 여러 데이터 형식을 지원한다.
    - 따라서 다양한 방식으로 데이터를 활용할 수 있다.
    - 리스트형 데이터 입력과 삭제는 MySQL에 비해서 *10배* 정도 빠르다고 한다.

  

  - 메모리를 활용하면서 영속적인 데이터 보존이 가능하다.
    - 명령어로 명시적으로 삭제, Expires를 설정하지 않으면 데이터가 삭제되지 않는다.
    - **디스크에 데이터**를 **기록**하고 있기 때문에 Redis 메모리가 날라가도 데이터를 복구할 수 있다.
    - **스냅샷(기억장치)** 기능을 제공하여 메모리의 내용을 *.rdb 파일로 저장하여 해당 시점으로 복구 할 수 있다.
  - Redis Server는 1개의 **싱글 쓰레드**로 수행되며 따라서 서버 하나에 여러개의 서버를 띄우는 것이 가능하다.
    - **Master - Slave 형식**으로 구성이 가능함
    - **데이터 분실 위험**을 없애주는 것이 바로 Master - Slave 방식으로, 해당기능을 이용하여 실시간으로 데이터를 다른 서버에 복제한다.  
    - Master server가 down되어도 slave server로 접속하면 바로 서비스를 계속할 수 있다.

  

  - Memcached 보다 **다양한 API**를 지원한다.

    - 많은 양의 캐시를 업데이트를 해줘야하는 상황에서 Memcached를 사용하면 
      업데이트 해야하는 데이터 양만큼 set API를 호출해야 하는반면, Redis에서는 데이터의 크기를 쪼개서 mset을 호출하면 Memcached로 동작할 때 보다 빠른 시간안에 작업할 수 있다.

      ex) Memcached에서는 여러개의 캐시 데이터를 가져오는건 가능하지만 
      여러개의 캐시 데이터를 업데이트하는 API는 지원하지 않는다.<br>그런데 여러개의 캐시를 한번에 업데이트해야하는 경우 Redis에서는 *mset* 이라는 함수를 사용하면 된다.

      

- 단점

  - **메모리 파편화**가 발생하기 쉽다.

    - Redis는 **싱글 쓰레드**여서 스냅샷을 뜰 때 자식 프로세스를 하나 만들낸 후 
      새로 변경된 메모리 페이지를 복사해서 사용한다.

    - Redis는 **copy-on-write 방식**을 사용한다.

    - 보통 Redis를 사용할 때는 데이터 변경이 잦기 때문에 
      실제 메모리 크기만큼 자식 프로세스가 복사하게 된다.

    - 그래서 실제로 필요한 메모리 양보다 **더 많은 메모리**를 사용하게 된다.(2배)

      

  - 대규모 데이터에 대한 **응답 속도의 불안정성**

    - 대규모 트래픽으로 인해 많은 데이터가 업데이트되면 Redis와 Memcached는 **메모리 할당 구조**가 다르기 때문에 Redis가 Memcached에 비해서 속도가 불안정하다.

    - 

    - Redis는 jemalloc을 사용하는데 매번 malloc과 free를 통해서 메모리 할당이 이루어진다.<br>반면 Memcached는 slab 할당자를 이용하여 내부적으로는 메모리 재할당을 하지 않고 관리하는 형태를 취한다.

    - 이로 인해서 Redis는 **메모리 파편화**가 발생하며 이 할당 비용 때문에 응답 속도가 느려진다.

      >  *※ 다만 이는 극단적으로 봤을 때 발생하는 일로, 대규모 서비스에서도 Redis를 많이 도입하는 것으로 보아, 일반적으로 스타트업 등에서 사용하기에는 거의 무방하다고도 볼 수 있다.*



### CRUD에 따른 Redis 데이터 처리

- Read 요청시

  Redis 서버는 Client에서 Read 요청이 들어올때 **메인 서버**로부터 값을 가져와 저장한다.

  이때 메인 서버와 싱크된 데이터 이 외에 추가로 데이터 만료 시점을 처리하기 위해서 
  **현재 시간**이나 **만료 시간**을 함께 저장해야한다.

  

- CUD 요청시

  이 경우 앞의 과정과는 조금 다른데, 왜냐하면 데이터에 변화가 생겼기 때문이다. <br>따라서 해당하는 값의 데이터는 캐싱 값이 아닌 **현재 실시간 정보**를 보내줘야한다.
  그러기 위해 필요한 조치는 비교적 간단한데

  

  > **1.** 방문자의 CUD를 주서버에 요청 	<br>**2.**CUD 요청을 주서버에 반영하여 업데이트 	<br>**3.** 변경되기 전 데이터 값을 Redis에서 찾아 삭제 후 종료

  의 과정을 거치면 된다.
  여기서 가장 중요한 점은 캐싱을 제공하는 경우 단순하게 정보를 제공하는 부분만 고려하는 것이 아니라 다양한 상황에 대처 해야 한다는 점이다.
  CUD처럼 **데이터에 중요한 변경 사항**이 있는 경우 **기존의 캐싱 데이터를 삭제**하는 과정이 그러하다.

[이전](./20.md)|[index 페이지로](./00index.md) |[다음](./21.md)
---|---|---
<hr>
