# 22 Spring-Cache

[이전](./21.md)|[index 페이지로](./00index.md) |[다음](./23.md)
---|---|---
<hr>


### 목차

1.
1.
1.

# Spring cache, ehcache 구현



### Cache

- 일반적으로 애플리케이션에서 데이터베이스를 접근하게 되면 많은 시간과 비용을 소비하게 된다. 
- 그래서 반복적으로 일어나면서 많은 양의 데이터를 가지고 와야 하는 작업은 부담이 되기에이러한 문제를 해결하기 위한것이 캐시이다. 
- 좀더 간단히 말해 캐시란 동일한 요청이 들어오면 복잡한 작업을 수행해서 결과를 만드는 대신 **이미 보관된 결과를 바로 돌려주는 방식**을 말한다. 
- 즉 **캐시를 사용하면 데이터베이스 접근하는 횟수를 획기적으로 개선**할 수 있다.



### Spring Cache

- Spring에서 지원하는 이러한 Cache 기능이 Spring caching abstraction이다.
- Spring caching abstraction는 다른 캐시 솔루션을 Spring CacheManager를 통해서 쉽게 사용할 수 있도록 해준다. 
- Spring CacheManager는 다양한 캐시의 솔루션들을 코드에 최소의 영향으로 다양한 캐싱 솔루션(라이브러리)을 도입할 수 있게 해준다. 
- Spring caching abstraction은 자바 메소드에 캐싱을 적용한다. <br>따라서 메소드가 실행될 떄마다 메소드의 넘어온 파라미터에 따라 캐쉬를 적용하게 된다. 

> ex) 2초이상걸리는 A라는 메소드를 호출 했을 때 파라미터로 1의 값을 넘겼고, 결과값 으로 2를 받았다고 하자. 
>
> 그리고 그다음에 다시 한번 누군가가 A메소드를 1의 파라미터를 넘겼으면 A메소드는 2초의 시간이 걸리지 않고 캐시되어 있는 데이터 2를 바로 리턴해준다. 이것의 범위는 애플리케이션내의 범위이다.



### Spring Cache 다양한 캐시 솔루션 도입방법

- Spring 3.1 부터 간단하게 캐시를 도입할 수 있게 되었다.

-  Spring에서 제공해주는 CacheManager인터페이스만 구현체에 따라 구현 해주면 되며, 다른 캐시 라이브러리들을 추가해서 구현체에 사용할 수 있다.

- Spring Boot에서 캐시를 사용하기위해서는 spring-boot-starter-cache를 추가하는데 기본적으로 spring-boot-starter-cache 이외에 아무 서드파트 라이브러리를 추가 하지 않는다면 기본설정인 **SimpleCacheConfiguration** 가 동작하며 CacheManager로는 **ConcurrentMapCacheManager가 빈으로 등록**이 된다. 

- ConcurrentMapCacheManager는 가벼워서 많이들 사용하나 Product용으로는 Ehcache 사용하는 것 같다. **Ehcache를 사용하면 좀 더 확장적이고 분산시스템등 커스터마이징을 할 수 있**기 때문이다.

  

### Spring Cache 사용방법



```xml
<dependency> 
	<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

- 위의 dependency를 pom.xmld에 추가후, `@EnableCaching`를 선언하면Spring container에 빈이 등록된다.  (기본적으로는 위에서 말햇듯이 ConcurrentMapCacheManager이 등록된다.)

- 상황에 따라 다른 캐시 구현체를 등록할 수 도 있으며, 해당 Cache를 적용하고 싶은 메소드에 `@Cacheable`을 붙이면 된다.

- 스프링 캐시 어노테이션과 속성은 다음과 같다. 

  - 스프링 캐시 어노테이션

    | 어노테이션     | 설명                             |
    | :------------- | :------------------------------- |
    | @Cacheable     | 메소드에 캐시 트리거 설정        |
    | @CachePut      | 메소드 실행과 방해없이 캐시 갱신 |
    | @CacheEvict    | 캐시되있는 데이터 지우기         |
    | @CacheConfig   | 캐쉬 관려설정                    |
    | @EnableCaching | 스프링 캐시활성화                |

    

  - 캐시 어노테이션들의 속성

    | 어노테이션     | 설명                                                    |
    | :------------- | :------------------------------------------------------ |
    | value          | 캐시의 이름                                             |
    | key            | 캐시할 키를 설정(기본설정하지 않으면 파라미터로 설정됨) |
    | condition      | 특정 조건에 따라 캐시를 할지 않을지 결정                |
    | cacheManager등 | 해당 캐시 매니저 설정가능                               |

    > 더 많은 설정에 대해선 [공식문서](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/cache.html) 참조

  

#### Spring Cache ConcurrentMapCacheManager 적용

- ConcurrentMapCacheManager를 이용한 간단한 캐시를 구현소스이다.

  

```java
@SpringBootApplication
@EnableCaching //Spring Cache를 사용하겠다고 선언
public class CacheApplication {
    
    public static void main(String[] args) {			                       
        SpringApplication.run(CacheApplication.class, args);	
    }
}
```



```java
@Cacheable(value = "members") //사용하고자 하는메소드위에 @Cacheable 어노테이션을 적는다. 이렇게 되면 캐시기능이 적용됨.
public Member findById(long id){
System.out.println("test");
     	return id == 1?
        	Member.builder().id(1).age(15).name("김철수").build():
       			Member.builder().id(2).age(17).name("jojo").build();  //삼항연산자로 반환  
     }
```

- `findById` 메소드에 멤버 id로 1이라는 id를 호출한 후에 다시 한번 똑같은 id로 호출하게 되면 이 `findById`메소드를 타지않고 캐시 되어 있는 데이터를 가지고오는것을 확인할 수 있다.
- 여기에서 제대로 캐시기능이 적용 되었는지 테스트하기위해서 System.out.println(“test”)로 로거를 찍었는데 2번이상 1번아이디의 유저를 호출하려고 해도 한번만 test가 로그에 찍힌다.



#### Spring Cache Ehcache 적용

- Ehcache를 사용하기 위해서는 아래와 같이 메이븐을 추가해줘야 한다.

  ```xml
  <dependency>
  	<groupId>net.sf.ehcache</groupId>
      <artifactId>ehcache</artifactId>
      <version>2.10.2.2.21</version>
  </dependency>
  ```

- 그 다음 아래와 같이 xml 설정을 해줘야 한다.세부 내용은 [공식 홈페이지](http://www.ehcache.org/)에서 확인할 수 있다.

  ```xml
  <ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="ehcache.xsd"
      updateCheck="true"
      monitoring="autodetect"
      dynamicConfig="true">
  
      <diskStore path="java.io.tmpdir" />
  
      <cache name="members"
          maxEntriesLocalHeap="100"
          maxEntriesLocalDisk="1000"
          eternal="false"
          timeToIdleSeconds="300"
          timeToLiveSeconds="600"
          memoryStoreEvictionPolicy="LFU"
          transactionalMode="off">
          <persistence strategy="localTempSwap" />
      </cache>
      
  </ehcache>
  ```

  

- 위의 내용을 간단히 설명하면
  1. 'members’라는 캐시의 이름을 선언했다.
  2.  최대 100개의 member들을 heap store에 담을 수 있다.
  3.  최대 1천개의 members은 diskStore에(java.io.tmpdir) 보관될 것이다. 
  4. 해당 member가 5분 이상 변화가 없거나 10분 이상 살아있다면 캐시는 만료 될 것이다.



[이전](./21.md)|[index 페이지로](./00index.md) |[다음](./23.md)
---|---|---
<hr>
