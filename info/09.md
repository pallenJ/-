# 9

[이전](./08.md)|[index 페이지로](./00index.md) |[다음](./10.md)
---|---|---
<hr>

### 목차
1. 
1.
1.

### SQL injection
  
  - 유해한 SQL문을 삽입하는 코드 인젝션 공격 기법
  - 개발자가 생각지 못한 SQL문을 실행되게 함으로써 데이터베이스를 비정상적으로 조작하는 코드 인젝션으로,
웹 애플리케이션의 허점을 악용해 애플리케이션의 개발자가 예상하지 못했던 SQL 문장이 실행되게 함으로써 데이터베이스를 비정상적으로 조작하는 공격
가장 빈번하게 일어나는 웹 해킹 공격임
  
  ex) <br>
  
  ```java
  public void getAdminInfo(){
  jdbcTemplate.query("SELECT * FROM users WHERE username='?' AND password='?'"
  , "admin","password' OR 1=1 --").forEach(e->log.info(e));
  }
  // log4j가 적용되어 있다고 가정
  ```
  위 코드에서 만약 injection이 작동하지 않고 그대로 ?에 해당 문자열이 들어갈경우 아래의 쿼리가 실행되게 되어 콘솔창에 찍힌다.
  ```sql
    SELECT * FROM users WHERE username='admin' AND password='password' OR 1=1 --'
  ```
  
1. prepare statement
  
   + 데이터베이스 관리 시스템(DBMS)에서 동일하거나 비슷한 데이터베이스 문을 높은 효율성으로 반복적으로 실행하기 위해 사용되는 기능. 
   + 일반적으로 쿼리나 업데이트와 같은 SQL 문과 함께 사용되는 프리페어드 스테이트먼트는 템플릿의 형태를 취하며, 그 템플릿 안으로 특정한 상수값이 매 실행 때마다 대체됨.
   + MySQL,[1] 오라클,[2] DB2,[3] 마이크로소프트 SQL 서버[4], PostgreSQL을 포함한 주요 DBMS들은 프리페어드 스테이트먼트를 폭넓게 지원
   + 예시(mysql 기준)
   ```java
 	import java.sql.Connection;
 	import java.sql.PreparedStatement;
 	import java.sql.ResultSet;
 	import java.sql.SQLException;
 	import java.sql.Statement;
 	
 	import org.junit.Test;
 	import org.junit.runner.RunWith;
 	import org.springframework.beans.factory.annotation.Autowired;
 	import org.springframework.test.context.ContextConfiguration;
 	import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 	import org.zerock.service.SampleService;
 	
 	import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
 	
 	import lombok.Setter;
 	import lombok.extern.log4j.Log4j;
 	
 	@RunWith(SpringJUnit4ClassRunner.class)
 	@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
 	@Log4j
    public class PSTest {
      
      @Test
      public void test() throws SQLException {
        MysqlDataSource ds = new MysqlDataSource();
        ds.setDatabaseName("mysql");
        ds.setUser("root");

        try (Connection conn = ds.getConnection()) {
          try (Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("CREATE TABLE IF NOT EXISTS products (name VARCHAR(40), price INT)");// 테이블 생성
          }

          try (PreparedStatement stmt = conn.prepareStatement("INSERT INTO products VALUES (?, ?)")) {
            stmt.setString(1, "bike");
            stmt.setInt(2, 10900);
            stmt.executeUpdate();
            stmt.setString(1, "shoes");
            stmt.setInt(2, 7400);
            stmt.executeUpdate();
            stmt.setString(1, "phone");
            stmt.setInt(2, 29500);
            stmt.executeUpdate();
          }//넣을 값 입력

          try (PreparedStatement stmt = conn.prepareStatement("SELECT * FROM products WHERE name = ?")) {
            stmt.setString(1, "shoes");
            ResultSet rs = stmt.executeQuery();// INSERT 쿼리 실행
            rs.next();
            System.out.println(rs.getInt(2));// 2번째 넣은 값이 나오면 성공
          }
        }
      }
    }
   ```
   + mybatis로 mapper페이지에서 처리 가능.
     * 자세한건 [exe01](https://github.com/pallenJ/booke/tree/master/exe01)프로젝트 참조
      
   
   
[이전](./08.md)|[index 페이지로](./00index.md) |[다음](./10.md)
---|---|---
