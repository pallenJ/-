
# 2. 정렬

### Bubble Sort

- 요약

  서로 인접한 두 원소를 검사하여 정렬하는 알고리즘.
  인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
  선택 정렬과 기본 개념이 유사하다.

  

- 상세

  오른쪽 끝에서 왼쪽 방향으로 옳겨가며 두개의 숫자를 비교한다.( n-1번째 수와 n 번째수, ... , 1번째수와 2번째 수 )이때 왼쪽의 수가 오른쪽보다 클경우 두 숫자의 위치를 바꾸고 다음으로 넘어간다.

  한바퀴 다 돌고나면 왼쪽 끝 숫자를 제외하고 다시 한바퀴를 돈다. 이런식으로 n-1번 반복하고 나면 정렬이 완료된다.



- 원리

  소위 말하는 노가다식 방법이다. 한바퀴 돌때 마다 두 숫자중 최소값을 가져오고 그 값이 다음에 나올 숫자보다 더 작은지 다시 검사하는 방식으로 먼저 최소값을 뽑는다.

  비유하자면 당구공 몇개가 섞여있는 것을 각각 짝지어 비교하면서 결국 가장 숫자가 작은것을 맨앞에 두고, 남은것들에서 다시 이 작업 반복하여 섞는다.

  이 방식의 최악의 수행횟수는  (n²-n)/2이므로 시간 복잡도는 *O*(n²)이다.

- 소스코드 (자바)

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class SortEx {

	public static void main(String[] args) {
		System.out.println(bubbleSort( Arrays.asList(new Integer[] {4,1,5,23,12})));
        // 본래 안쓰는게 좋음. asList로 만든 리스트는 입출력시 에러남
	}
	
	public static List<Integer> bubbleSort(List<Integer> list){
		int size = list.size();
		for(int i=0;i<size -1;i++){
			for(int j = size -1;j>i;j--){
				if(list.get(j-1)>list.get(j)) {
					Collections.swap(list, j-1, j);
				}
			}
		 }
		return list;
	} 
	
}
```

> 결과 [1, 4, 5, 12, 23]
>
> 아래에서 부턴 main부분은 생략

### Select Sort

선택 정렬은 사실 버블 정렬과 거의 비슷하다.

둘다 최소값을 가져와서 맨 왼쪽에 놓고 남은 것에서 같은 작업을 반복해서 정렬한다는 점에서 같다.

다른점이 있다면 버블 정렬은 최소값을 찾을때 두개씩 각각 비교후 왼쪽으로 가면서 최소값을 찾아 옮기는 반면 선택정렬은 최소값을 선형 탐색으로 찾는다는 점이다.

사실 이 두가지 방법은 효율성이나 방식에 유의미한 차이는 없다고 봐도 된다.

따라서 시간 복잡도 역시 동일하게 *O*(n²)이다.



- 소스코드

```java
	public static List<Integer> selectSort(List<Integer> list) {
		List<Integer> sorted = new ArrayList<Integer>();
		int minIdx = 0;
		while (list.size() > 0) {

			for (int i = 0; i < list.size(); i++) {
				if (list.get(i) < list.get(minIdx))
					minIdx = i;
			}
			sorted.add(list.get(minIdx));
			list.remove(minIdx);
			minIdx = 0;
		}

		return sorted;
	}
```



> 위와 다르게 Arrays.asList는 remove, add에서 에러나므로 직접 List에 담아야함.



### Insert Sort



이 방법은 순서대로 숫자를 꺼내어 위치를 잡아 정렬하는 것이다.

앞선 방법들이 최솟값을 찾아 차곡차곡 쌓은 것이라면 이쪽은 하나씩 값을 옮기면서 옳은 위치에 값을 넣어가는 정렬 방식이다.

선택 정렬의 방식에서 가져온다음 정렬하느냐 가져오면서 정렬하느냐 정도의 차이기에 효율성면에서도 동일하게 *O*(n²)의 시간 복잡도를 가진다.



```java
	public static List<Integer> insertSort(List<Integer> list){
		List<Integer> rs = new ArrayList<Integer>();
		while(list.size()>0) {
			int idx = 0,val = list.get(0);
			for (Integer integer : rs) {
				if(integer>val) break;
				idx ++;
			}
			rs.add(idx,val);list.remove(0);
		}
		return rs;
	}
```



### Heap Sort

힙구조를 이용한 정렬로, 힙에 정렬하고자하는 모든 숫자를 내림차순으로 넣은 뒤 하나씩 빼고 재구축하며 정렬하는 방식이다.<br>
1회 추가당 최악의 시간복잡도는 log₂ n이므로 전체 시간 복잡도는 *O*(log n)이다.


```java
import java.util.Arrays;

public class Heap {
    int size;
    int heaps[];
 
    public Heap() {
        size = 0;
        heaps = new int[50];
    }
    
    public Heap(int heapSize) {
    	size = 0;
    	heaps = new int[heapSize];
    }
 
    public Heap(Integer [] arr) {
    	size = 0;
    	heaps = new int[50];

    	for (int i : arr) {
			this.insertHeap(i);
		}
    	
    }
    public Heap(int heapSize, Integer [] arr) {
    	size = 0;
    	heaps = new int[heapSize];
    	for (int i : arr) {
			this.insertHeap(i);
		}
    }
    
    public void insertHeap(int item) {
        int i = ++size;
 
        while ((i != 1) && (item > heaps[i / 2])) {
            heaps[i] = heaps[i / 2];
            i /= 2;
        }
        heaps[i] = item;
    }
 
    
    public int deleteHeap() {
        int parent, child;
        int item, tmp;
        item = heaps[1];
        tmp = heaps[size--];
        parent = 1;
        child = 2;
 
        while (child <= size) {
            if ((child < size) && (heaps[child] < heaps[child + 1]))
                child++;
 
            if (tmp >= heaps[child])
                break;
 
            heaps[parent] = heaps[child];
            parent = child;
            child *= 2;
        }
 
        heaps[parent] = tmp;
        return item;
    }
    
	
	  public static Integer[] heapSort(Integer[] arr) {
		  Heap heap = new Heap(arr);
	       for (int i = arr.length - 1; i >= 0; --i) {
	            arr[i] = heap.deleteHeap();
	        }
	       return arr;
	  }
	 
    
    public static void main(String[] args) {
    	
		System.out.println(
				Arrays.asList(//결과값을 보기위해 asList사용
						heapSort(new Integer [] {32,44,11,43,10,72,65})));
    	
	}
    
}


```

> 결과 : [10, 11, 32, 43, 44, 65, 72]


### Merge Sort(병합정렬)



병합정렬은 정렬하고픈 수열을 둘로 분할해 나가서 더이상 분할 할 수 없는 상태에 이르면 그룹을 병합하며 정렬한다.

어차피 그룹에 각각 하나씩만 숫자가 남을때까지 분할하기에 분할 작업은 생략한다고 생각하고 각 원소를 병합하면서 정렬하는 방식이라고 생각해도 무방하다.

각 단계에서 분할된 그룹의 단계는 log₂ n 개 이고, 몇번째 병합 단계이건 숫자들의 총 개수는 n 이므로 시간복잡도는 *O*(n log n)이 된다. 



```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class MergeSort 
{

    public static void main( String[] args ){
       System.out.println(sort(new ArrayList<>(Arrays.asList(22,1,23,192,543,1024,11,534,213,455))));
    }

    public static List<Integer> sort(List<Integer> list) {
    	if(list.size() < 2) { return list;}
        return merge(
        		sort(list.subList(0, list.size() / 2)),
        		sort(list.subList(list.size() / 2, list.size()))	);
        // 재귀 함수로 쪼갤 수 있을때까지 쪼갠 뒤 sort가 동작.
        
    }
    
    private static List<Integer> merge (List<Integer> left, List<Integer> right) {
        List<Integer> rs = new ArrayList<>();
        int rightIdx = 0;

        for (Integer lnum : left) {
            while (right.size() > rightIdx && lnum > right.get(rightIdx)) {
                rs.add(right.get(rightIdx++));
            }
            rs.add(lnum);
        }
        //정렬&병합
        rs.addAll(right.subList(rightIdx, right.size()));
        return rs;
        
    }
}
```

> 결과 : [1, 11, 22, 23, 192, 213, 455, 534, 543, 1024]
